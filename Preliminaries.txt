PRELIMINARIES

//Setup

    Board
      - 10x10
      - Board from player and computer shown
      - GUI

    Ships
      - Placing ships by asking for coordinates or ask for the users to click
        the squares where he wants his ships
      - Computer places his ships at random (random factor required according
        to assignment)
      - Keep track of where ships are placed in an array
      - Not 100% sure whether it is necessary to create ship objects.
        -> just create coordinates and use these in combination with the board
        -> e.g. board[x][y] = 1;
                board[x + 1][y] = 1;
                board[x][y + 1] = 1;
                board[x + 1][y + 1] = 1;
        -> where x and y are random integers generated by a math.random()
          function
        -> the cells get marked 1, if hit should be marked 0
        -> how to implement this for multicell ships?
      - make sure that placing ships outside the board is restricted
      - the computer may select a cell at random to place a ship but should
        also check if there is sufficient space for the ship to be placed.
        Borders of the board are constraining
      - Also: ships may never overlap

    Bombs
      - Throwing a bomb for the user is fairly easy, by clicking the opponents
        cells on the board
      - When a bomb is thrown the cell where it lands should be marked
        (visually and in the backend as for instance 0)
      - When hit and a ship present, still mark cell and indicate that a ship
        was hit
      - Throwing bombs for the computer is where it gets difficult
        - Computer should be able to analyse what are the most likely positions
          for the opponent's ships to be
          - For the first (few) move(s) this clearly does not matter
          - Even though the computer should - at a high difficulty level -
          be able to figure out the most efficient pattern to throw bombs in
          opening game to hit as fast as possible. This requires for the
          computer to take into consideration the different types of ships and
          all possible setups.
          - As soon as it has a hit it should continue reasoning and looking
          for the squares where it is most likely to hit a ship
        - Which algorithm is suitable here?

    Scores and level of difficulty
      - # of hits it takes either player to take out all ships
        - More complex: score per hit increases if consecutive hits are made
          or the most important ships are taken out first and is lower for
          the hits following some misses.
      - (required) Level of difficulty could be the search depth of the
        algorithm or if we decide to use a different type of algorithm, the
        probabilistic accuracy of the a ship or a part of a ship being located
        at a certain cell. A lower accuracy simply means more error allowed.
        Termination threshold for the algorithm rather low.
      - The score should be stored so that when closing and opening up again

    Making moves
    Winning and Losing
    General handler class with the main function

//Minimal Requirements (you may go above and beyond!):

  • A grid of tiles which can contain one of several things:
    o Terrain (e.g. blinding spot lights, slippery dance floor): terrain tiles may
      influence your player positively or negatively (e.g. when challenging a Juror
      near a slippery dance floor, the player’s dance skills are temporarily
      decreased)
    o Opponents (e.g. jurors and stars): overcoming opponents should be evaluated
      based on your player’s skills and should include some random element (e.g. a
      Juror has a random threshold which a player’s dancing skills should be above,
      in order to impress that Juror)
    o Prize (e.g. trophy): there should be some minimum requirements the player
      must meet before they can claim the prize
    o The tiles should be randomly assigned for each new game.

  • Difficulty Levels:
    o You should offer different difficulty levels for the user to choose. The levels
      should make the game harder or easier, but how they actually impact it is up to
      you, (e.g. higher difficulty level results in a larger game board and less energy)

  • Visibility:
    o Only a specific radius of tiles around the Player is visible at any time

  • Your Player:
    o Players should have skill attributes (which can be chosen by the user and also
      impacted by game play, e.g. winning a dance off allows the player to gain
      looks or dancing skills)
    o Players have energy (or some similar measure); the game is lost when this
      runs out
    o Players can move from tile to tile, which costs some energy
  • High Scores:
    o You should keep track of high scores even when the game is closed, so that
      next time you play, your score is compared against the existing high scores.
